/**
*
*   Sort.js
*   @version: 0.2.3
*
*   Sorting Algorithms implemented in JavaScript
*   https://github.com/foo123/SortingAlgorithms
*
**/!function(r,t,e,i,n){e=e?[].concat(e):[];var o,a,s=Array,u=s.prototype,l=e.length,f=new s(l);if("object"==typeof module&&module.exports){if(n===module.exports[t]){for(o=0;l>o;o++)f[o]=module.exports[e[o][0]]||require(e[o][1])[e[o][0]];a=i.apply(r,f),module.exports[t]=a||1}}else if("function"==typeof define&&define.amd)define(["exports"].concat(e.map(function(r){return r[1]})),function(o){if(n===o[t]){var s,l=u.slice.call(arguments,1),c=l.length;for(s=0;c>s;s++)f[s]=o[e[s][0]]||l[s];a=i.apply(r,f),o[t]=a||1}});else if(n===r[t]){for(o=0;l>o;o++)f[o]=r[e[o][0]];a=i.apply(r,f),r[t]=a||1}}(this,"Sort",null,function(r){var t={},e=t.Sort={VERSION:"0.2.3"};e.Array=Array,e.Array32F="undefined"!=typeof Float32Array?Float32Array:Array,e.Array64F="undefined"!=typeof Float64Array?Float64Array:Array,e.Array8I="undefined"!=typeof Int8Array?Int8Array:Array,e.Array16I="undefined"!=typeof Int16Array?Int16Array:Array,e.Array32I="undefined"!=typeof Int32Array?Int32Array:Array,e.Array8U="undefined"!=typeof Uint8Array?Uint8Array:Array,e.Array16U="undefined"!=typeof Uint16Array?Uint16Array:Array,e.Array32U="undefined"!=typeof Uint32Array?Uint32Array:Array,e.utils={};var i,n=Math.min,o=Math.max,a=Math.sqrt,s=Math.log,u=Math.random,l=e.utils.RandomInteger=function(r,t){return~~((t-r)*u()+r)},f=e.utils.Uniform=function(t,e){return t=r===t?0:t,e=r===e?1:e,(e-t)*u()+t},c=!1;e.utils.Gauss=function(t,e){if(t=r===t?0:t,e=r===e?1:e,c)return c=!1,t+e*i;for(var n,o,u,l,h,g=!0;g;)n=f(-1,1),o=f(-1,1),u=n*n+o*o,g=0>=u||u>=1;return l=a(-2*s(u)/u),i=o*l,c=!0,h=n*l,t+e*h},e.utils.Sign=function(r){return r?0>r?-1:1:0},e.utils.asNumbers=function(r,t){return r-t},e.Shuffle=function(r){for(var t,e,i=r.length;i--;)t=l(0,i),e=r[i],r[i]=r[t],r[t]=e;return r},e.isSorted=function(r,t){var e,i,n,o,a,s=r.length;if(1>=s)return!0;if(t=t||!1,i=r[1]-r[0],o=i?0>i?-1:1:0,t&&0>o)return!1;for(a=o?!1:!0,e=1;s>e;e++){if(i=r[e]-r[e-1],n=i?0>i?-1:1:0,a&&n&&(o=n,a=!1),t&&0>n)return!1;if(n&&n-o)return!1}return!0},e.utils.Constant=function(r,t){var e=new Array(r);for(t=t||0;r--;)e[r]=t;return e},e.utils.Duplicates=function(r,t,e){var i,n,o=new Array(r),a=t;for(n=0,i=0;r>i;i++)o[i]=a,n>=e&&(n=0,a+=t),n++;return o},e.utils.Range=function(r){for(var t=new Array(r);r--;)t[r]=r;return t},e.utils.ReverseRange=function(r){for(var t=new Array(r),e=r;e--;)t[e]=r-1-e;return t},e.utils.Equidistant=function(r,t,e,i){var n,o=new Array(r),a=t;for(n=0;r>n;n++)o[n]=a,a+=i;return o},e.utils.IntegerEquidistributable=function(r,t,e){var i,n=new Array(r);for(i=0;r>i;i++)n[i]=l(t,e);return n},e.utils.NumberEquidistributable=function(r,t,e){var i,n=new Array(r);for(i=0;r>i;i++)n[i]=f(t,e);return n},e.utils.IntegerDynamicRange=function(r,t,e,i,n){var o,a,s=new Array(r),u=0;for(a=0,o=0;r>o;o++)s[o]=l(t,e)+u,a>=n&&(a=0,u+=i),a++;return s},e.utils.NumberDynamicRange=function(r,t,e,i,n){var o,a,s=new Array(r),u=0;for(a=0,o=0;r>o;o++)s[o]=f(t,e)+u,a>=n&&(a=0,u+=i),a++;return s};var h=e.utils.Timer=function(t){var e=r!==t?t:(new Date).getTime(),i=1/0,a=1/0,s=0;this.getMs=function(){var r=i-e;return a=n(a,r),s=o(s,r),r},this.start=function(){return e=(new Date).getTime(),this},this.end=function(){return i=(new Date).getTime(),this},this.reset=function(){return e=(new Date).getTime(),i=1/0,this},this.update=function(){return i=(new Date).getTime(),e=i,this}},g=Array.prototype.slice;return e.Time=function(r,t){var e,i,n=300,o=300,a=n+o;return t&&(i=g.call(arguments),i.shift(),i.shift(),e=new h,e.start(),setTimeout(function(){t.apply({},i),setTimeout(function(){e.end();var t=e.getMs()-a;r&&r.call(e,t)},o)},n)),0},e.vTime=function(r,t,i){return i=i||[],e.Time.apply(e,[r,t].concat(i))},!function(r){"use strict";var t=r.utils.asNumbers;r.BuiltinSort=function(r){return r.sort(t),r},r.BuiltinSort.reference="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort",r.BuiltinSort.description="This is JavaScript's builtin algorithm, usually a variation of quicksort."}(e),!function(r){"use strict";r.BubbleSort=function(r){var t,e,i,n=r.length;if(n>1)do{for(e=0,t=1;n-1>=t;t++)r[t-1]>r[t]&&(i=r[t-1],r[t-1]=r[t],r[t]=i,e=t);n=e}while(n>0);return r},r.BubbleSort.reference="http://en.wikipedia.org/wiki/Bubble_sort",r.BubbleSort.description="Bubble sort is a simple sorting algorithm that works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted."}(e),!function(r){"use strict";r.CocktailSort=function(r){var t,e,i,n,o,a=r.length;if(a>1){t=-1,e=a-2;do{for(i=!1,t++,n=t;e>=n;n++)r[n]>r[n+1]&&(o=r[n],r[n]=r[n+1],r[n+1]=o,i=!0);if(0==i)break;for(i=!1,e--,n=e;n>=t;n--)r[n]>r[n+1]&&(o=r[n],r[n]=r[n+1],r[n+1]=o,i=!0)}while(i)}return r},r.CocktailSort.reference="http://en.wikipedia.org/wiki/Cocktail_shaker_sort",r.CocktailSort.description="Cocktail sort is a variation of bubble sort that is both a stable sorting algorithm and a comparison sort. The algorithm differs from a bubble sort in that it sorts in both directions on each pass through the list. This sorting algorithm is only marginally more difficult to implement than a bubble sort, and solves the problem of turtles in bubble sorts."}(e),!function(r){"use strict";var t=[701,301,132,57,23,10,4,1],e=t.length;r.ShellSort=function(r){var i,n,o,a,s,u=r.length;if(1>=u)return r;for(o=0;e>o;o++)for(i=t[o],a=i;u>a;a+=i){for(n=r[a],s=a;s>=i&&r[s-i]>n;s-=i)r[s]=r[s-i];r[s]=n}return r},r.ShellSort.reference="http://en.wikipedia.org/wiki/Shellsort",r.ShellSort.description="Shellsort is an in-place comparison sort. It generalizes an exchanging sort, such as insertion or bubble sort, by starting the comparison and exchange of elements with elements that are far apart before finishing with neighboring elements. Starting with far apart elements can move some out-of-place elements into position faster than a simple nearest neighbor exchange."}(e),!function(r){"use strict";var t=Math.floor,e=function(r,t,i){var n,o=2*t+1,a=2*t+2,s=t;i>o&&r[o]>r[t]&&(s=o),i>a&&r[a]>r[s]&&(s=a),s!==t&&(n=r[t],r[t]=r[s],r[s]=n,e(r,s,i))},i=function(r){var i,n=r.length;for(i=t(n/2);i>=0;i--)e(r,i,n);return r};r.HeapSort=function(r){var t,n,o=r.length;if(1>=o)return r;for(i(r),n=o-1;n>0;n--)t=r[0],r[0]=r[n],r[n]=t,o--,e(r,0,o);return r},r.HeapSort.reference="http://en.wikipedia.org/wiki/Heap_sort",r.HeapSort.description="Heapsort is a comparison-based sorting algorithm to create a sorted array (or list), and is part of the selection sort family. Although somewhat slower in practice on most machines than a well-implemented quicksort, it has the advantage of a more favorable worst-case O(nlogn) runtime."}(e),!function(r){"use strict";r.InsertionSort=function(r){var t,e,i,n=r.length;if(n>1)for(t=1;n>t;t++){for(e=r[t],i=t;i>0&&e<r[i-1];)r[i]=r[i-1],i--;r[i]=e}return r},r.InsertionSort.reference="http://en.wikipedia.org/wiki/Insertion_sort",r.InsertionSort.description="Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages.."}(e),!function(r){"use strict";r.CycleSort=function(r){var t,e,i,n,o,a=r.length;if(a>1)for(t=0;a>t;t++){for(e=r[t],i=t,n=t+1;a>n;n++)r[n]<e&&i++;if(i!=t){for(;e==r[i];)i++;for(o=r[i],r[i]=e,e=o;i!=t;){for(i=t,n=t+1;a>n;n++)r[n]<e&&i++;for(;e==r[i];)i++;o=r[i],r[i]=e,e=o}}}return r},r.CycleSort.reference="http://en.wikipedia.org/wiki/Cycle_sort",r.CycleSort.description="Cycle sort is an in-place, unstable sorting algorithm, a comparison sort that is theoretically optimal in terms of the total number of writes to the original array, unlike any other in-place sorting algorithm. It is based on the idea that the permutation to be sorted can be factored into cycles, which can individually be rotated to give a sorted result."}(e),!function(r){"use strict";var t=function(r,t,e,i){for(var n,o;;){if(n=e+~~(.5*(i-e)),e==i)return null!==r[n]&&r[n]<=t?n+1:n;for(o=n;i>o&&null===r[o];)o++;if(o!=i)if(o!=e){if(r[o]==t)return o+1;r[o]>t?i=o-1:e=o+1}else{if(r[o]>t)return o;e=o+1}else{if(null!==r[o]&&r[o]<=t)return o+1;i=n}}},e=function(r,t,e,i){var n;if(null===r[e])r[e]=t;else{for(;null!==r[e];)n=r[e],r[e]=t,t=n,e++;r[e]=t,e++}e>i[0]&&(i[0]=e)},i=function(r,t,e,i){var n,o,a,s,u,l,f=r.length;for(n=new Array(f),o=a=1,s=u=0;e>o;){for(l=0;t>l;)null!==r[a]&&(n[u]=r[a],u++),r[a]=null,a++,l++;null!==r[a]&&(n[u]=r[a],u++),r[a]=n[s],a++,s++,o++}i[0]=a-1};r.LibrarySort=function(r,n){var o,a,s,u,l,f,c,h,g,d,m=r.length;for(n=n||0,s=~~(n*m+.5),a=m+s,o=new Array(a),g=0;a>g;g++)o[g]=null;for(o[0]=r[0],u=[0],l=f=1;m>l;){for(c=l;m>l&&c>0;)h=t(o,r[f],0,u[0]),e(o,r[f],h,u),c--,l++,f++;i(o,s,l,u)}for(d=0,g=0;a>g;g++)null!==o[g]&&(r[d++]=o[g]);return r},r.LibrarySort.reference="http://en.wikipedia.org/wiki/Library_sort",r.LibrarySort.description="Library sort, or gapped insertion sort is a sorting algorithm that uses an insertion sort, but with gaps in the array to accelerate subsequent insertions. Like the insertion sort it is based on, library sort is a stable comparison sort and can be run as an online algorithm; however, it was shown to have a high probability of running in O(nlogn) time (comparable to quicksort), rather than an insertion sort's O(n<sup>2</sup>)."}(e),!function(r,t){"use strict";var e=Array.prototype.splice,i=Math.min,n=function(r,t,i,n){if(n>t){for(var o=n-t+1,a=new Array(o),s=0,u=t,l=i+1;i>=u&&n>=l;)a[s++]=r[u]<=r[l]?r[u++]:r[l++];for(;i>=u;)a[s++]=r[u++];for(;n>=l;)a[s++]=r[l++];e.apply(r,[t,o].concat(a))}return r},o=r.RecursiveMergeSort=function(r,e,i){if(t===e&&t===i&&(e=0,i=r.length-1),i>e){var a=~~(e+.5*(i-e+1));o(r,e,a-1),o(r,a,i),n(r,e,a-1,i)}return r};r.MergeSort=function(r){var t=r.length;if(t>1)for(var e,o,a=t,s=1,u=2;a;){for(o=t-s,e=0;o>e;e+=u)n(r,e,e+s-1,i(e+u-1,t-1));s<<=1,u<<=1,a>>=1}return r},r.RecursiveMergeSort.reference=r.MergeSort.reference="http://en.wikipedia.org/wiki/Merge_sort",r.RecursiveMergeSort.description=r.MergeSort.description="Merge sort is an O(nlogn) comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output. Mergesort is a divide and conquer algorithm."}(e),!function(r,t){"use strict";var e=function(r,t,e){var i,n,o,a,s;for(i=~~(t+.5*(e-t)),n=r[i],o=r[i],r[i]=r[e],r[e]=o,a=t,s=t;e>s;s++)r[s]<=n&&(o=r[s],r[s]=r[a],r[a]=o,a++);return o=r[a],r[a]=r[e],r[e]=o,a},i=r.RecursiveQuickSort=function(r,n,o){if(t===n&&t===o&&(n=0,o=r.length-1),o>n){var a;a=e(r,n,o),i(r,n,a-1),i(r,a+1,o)}return r};r.QuickSort=function(r,i,n){if(t===i&&t===n&&(i=0,n=r.length-1),n>i){var o,a,s,u;for(s=n-i+1,o=new Array(s),a=-1,o[++a]=i,o[++a]=n;a>=0;)n=o[a--],i=o[a--],u=e(r,i,n),u-1>i&&(o[++a]=i,o[++a]=u-1),n>u+1&&(o[++a]=u+1,o[++a]=n)}return r},r.RecursiveQuickSort.reference=r.QuickSort.reference="http://en.wikipedia.org/wiki/Quicksort",r.RecursiveQuickSort.description=r.QuickSort.description="Quicksort is a sorting algorithm that, on average, makes O(nlogn) comparisons to sort n items. In the worst case, it makes O(n<sup>2</sup>) comparisons, though this behavior is rare. Quicksort is often faster in practice than other O(nlogn) algorithms. Additionally, quicksort's sequential and localized memory references work well with a cache. Quicksort is a comparison sort and, in efficient implementations, is not a stable sort."}(e),!function(r){"use strict";r.TimSort=function(r){return r},r.TimSort.reference="http://en.wikipedia.org/wiki/Timsort",r.TimSort.description="<strong>NOT IMPLEMENTED YET</strong> Timsort is a hybrid sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. It is used in the Python programming language. The algorithm finds subsets of the data that are already ordered, and uses that knowledge to sort the remainder more efficiently. This is done by merging an identified subset, called a run, with existing runs until certain criteria are fulfilled. Timsort has been Python's standard sorting algorithm since version 2.3. It is used to sort arrays in Java SE 7, on the Android platform, and in GNU Octave."}(e),!function(r){"use strict";r.CountingSort=function(r){var t,e,i,n,o,a,s,u,l,f=r.length;if(f>1){for(t=e=r[0],a=1;f>a;a++)r[a]>e?e=r[a]:r[a]<t&&(t=r[a]);for(s=~~e+1,i=new Array(s),a=0;s>a;a++)i[a]=0;for(a=0;f>a;a++)i[~~r[a]]++;for(o=0,a=0;s>a;a++)n=i[a],i[a]=o,o+=n;for(l=r.slice(),a=0;f>a;a++)u=l[a],r[i[~~u]]=u,i[~~u]++}return r},r.CountingSort.reference="http://en.wikipedia.org/wiki/Counting_sort",r.CountingSort.description="Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers, that is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key value, and using arithmetic on those counts to determine the positions of each key value in the output sequence. Its running time is linear in the number of items and the difference between the maximum and minimum key values, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can handle larger keys more efficiently."}(e),!function(r){"use strict";var t=Math.floor,e=function(r){var t,e,i,n=r.length;for(i=1;n>i;i++){for(t=r[i],e=i-1;e>=0&&t<r[e];)r[e+1]=r[e],e--;r[e+1]=t}return r},i=function(r){var e,i,n,o=[],a=r.length,s=1/a;for(n=0;a>n;n++)i=r[n],e=t(i/s),o[e]||(o[e]=[]),o[e].push(i);return o},n=function(r,t){var e,i=r.length;for(e=0;i>e;e++)r[e]&&(r[e]=t(r[e]));return r},o=function(r){var t,e,i=[],n=r.length;for(t=0;n>t;t++)e=r[t],e&&(i=i.concat(e));return i},a=e;r.BucketSort=function(r,t){var e,s,u,l,f=r.length;if(a=t||a,f>1){for(s=i(r),n(s,a),e=o(s),l=f%2,u=0;f>u;u+=2)r[u]=e[u],r[u+1]=e[u+1];l&&(r[f-1]=e[f-1])}return r},r.BucketSort.reference="http://en.wikipedia.org/wiki/Bucket_sort",r.BucketSort.description="Bucket sort is a sorting algorithm that works by partitioning an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the most to least significant digit flavour. Bucket sort is a generalization of pigeonhole sort. Since bucket sort is not a comparison sort, the &Omega;(nlogn) lower bound is inapplicable. The computational complexity estimates involve the number of buckets."}(e),!function(r){"use strict";var t=r.Array,e=Math.round;Math.floor,r.PermutationSort=function(r){var t,e,i,n=r.length;if(n>1)for(t=r.slice(),e=0;n>e;e++)i=t[e],r[i]=i;return r},r.PermutationSort.reference="#A Custom Algorithm",r.PermutationSort.description="Algorithm for sorting permutations of the integer set [0, N-1], with no duplicates, by (trivial) re-indexing",r.IndexSort=function(r){var i,n,o,a,s,u,l,f,c,h,g,d,m,p,y,v,b=r.length;if(b>1){for(i=n=r[0],v=r[1]-r[0],m=v?0>v?-1:1:0,p=m?!1:!0,y=!0,s=1;b>s;s++)y&&(v=r[s]-r[s-1],d=v?0>v?-1:1:0,p&&d&&(m=d,p=!1),d&&d-m&&(y=!1)),r[s]>n?n=r[s]:r[s]<i&&(i=r[s]);if(y)return 0>d&&r.reverse(),r;for(o=(b-1)/(n-i),f=b,c=new t(b),l=new t(f),s=0;f>s;s++)l[s]=0;for(s=0;b>s;s++)v=r[s],u=c[s]=e(o*(v-i)),l[u]++;for(h=0,s=0;f>s;s++)g=l[s],l[s]=h,h+=g;for(a=r.slice(),s=0;b>s;s++)u=c[s],r[l[u]]=a[s],l[u]++}return r},r.IndexSort.reference="#A Custom Algorithm",r.IndexSort.description="Algorithm for sorting random numbers close to being 'homogeneous-equidistant' in [m, M], with possible duplicates, by re-indexing (an extended version of PermutationSort)"}(e),!function(r){"use strict";var t=r.Array64F,e=r.Array32U,i=Array.prototype.splice,n=(Math.floor,Math.round);Math.ceil,r.StatisticalSort=function(r){var o,a,s,u,l,f,c,h,g,d,m,p,y,v=r.length;if(v>1){for(o=v%2,c=h=r[0],f=r[1]-r[0],s=f?0>f?-1:1:0,u=s?!1:!0,l=!0,p=1;v>p;p++)l&&(f=r[p]-r[p-1],a=f?0>f?-1:1:0,u&&a&&(s=a,u=!1),a&&a-s&&(l=!1)),r[p]>h?h=r[p]:r[p]<c&&(c=r[p]);if(l)return 0>a&&r.reverse(),r;m=1/(h-c);var b,w=new e(v),S=new t(v+1),k=0;for(S[0]=0,g=m,d=v*g,b=-c+1,p=0;v>p;p+=2)S[p+1]=g*(r[p]+b)+S[p],S[p+2]=g*(r[p+1]+b)+S[p+1],w[p]=n(d*(r[p]+b)),w[p+1]=n(d*(r[p+1]+b));o&&(S[v]=g*(r[v-1]+b)+S[v-1],w[v-1]=n(d*(r[v-1]+b))),k=S[v],g=(v-1)/k;var A=new Array(v),I=new Array(v);for(p=0;v>p;p++)A[p]=null;for(p=0;v>p;p++)y=n(g*S[w[p]]),f=r[p],A[y]?(A[y].push(f),f>I[y][1]?I[y][1]=f:f<I[y][0]&&(I[y][0]=f)):(A[y]=[f],I[y]=new t([f,f]));w=S=null;var M,T,x,C,q,B=0;for(p=0;v>p;p++)if(null!==A[p]){if(M=A[p],T=M.length,x=I[p][0],C=I[p][1],x==C)i.apply(r,[B,T].concat(M));else for(g=(T-1)/(h-c),q=0;T>q;q++)y=n(g*(M[q]-x)),r[B+y]=M[q];B+=T,A[p]=I[p]=null}}return r},r.StatisticalSort.reference="#A Custom Algorithm",r.StatisticalSort.description="(in progress)"}(e),t.Sort});